# Python и DevOps: ключ к автоматизации Linux
## Принципы DevOps
Система CI собирает программное обеспечение в **бинарный файл или образ Docker** и выполняет **модульное тестирование**. Система CD развертывает собранные CI артефакты в **целевой среде**.

- Двустороннее сотрудничество специалистов разработки и эксплуатации; команде эксплуатации нужны навыки разработчиков, команде разработчиков - навыки эксплуатации.
- **Интегрируемые инструменты связи SaaS**
- Люди не должны участвовать в развертывании ПО на постоянной основе. Полный цикл задач эксплуатации занимает минуты-часы, реализованы конвейеры **CI/CD**.
- Петля обратной связи: сборка, тестирование, выпуск, мониторинг, планирование.
- **GitOps**.
- **IaC**.
- Не автоматизировано - значит сломано.
- **Микросервисы** > монолитная архитектура.
- **Агрегированное журналирование**: как на уровне приложения, так и на уровне среды. Исключения всегда должны отправляться в **централизованные журналы** для разработки **эвристических правил отладки**. Кроме того, наличие отдельного сервера позволяет обеспечить их целостность и защиту от отдельных администраторов.
- Использование облаков как реализация **принципа сравнительного преимущства**. 
- Реализация **отказоустойчивости**: сбой сервиса **рано или поздно произойдет**, и необходимо сократить ручное вмешательство при восстановлении, а также обеспечить **мониторинг**.

Конечные преимущества:
- скорость
- автоматизация
- надежность
- масштабируемость
- безопасность

## Мониторинг и журналирование

Утилиты мониторинга используют UDP, потому что **TCP-соединения блокируются до получения ответа**.
Prometheus подходит для **краткосрочных и часто меняющихся временных данных**, а Graphite для данных, **собранных за большой промежуток времени**.

Для синтаксического разбора журналов использовать ELK.

## Траблшутинг
Если информация, необхдимая для дебага не отображается в логах, можно использовать команду `strace` и посмотреть системные вызовы.

## Инфраструктурное тестирование

В отличии от `unittest`, `pytest` не навязывает использование классов, тем не менее, он позволяет писать юнит-тесты. Так же в нем присутствует **параметризация**, позволяя объединять в группы параметры `assert` и фикстуры.

- Каталог с тестами должен называться `tests`
- Названия файлов и функций должны начинаться с `test_` (это позволяет создавать вспомогательные функции и модули, которые будут автоматически исключаться из листинга)
- Названия классов должны начинаться с `Test`

С поомщью проекта Testinfra c pytest можно тестировать IaC - проверять конфигурацию, права доступа, пользователей, открытые порты и т.д. У Testinfra есть интеграция с Ansible, SaltStack, Docker и Kubernetes, Vagrant с SSH:

```
pytest --hosts='ansible://nginx' --conncection=ansible --ansible-inventory=hosts.yaml test_remote.py
```
Полезные фикстуры:
- `host.ansible` - свойства Ansible
- `host.addr` - проверка доступности и разрешимости хоста
- `host.docker` - прокси для API Docker
- `host.iptables`
- `host.process`
- `host.check_output` и `host.run` для запуска системных команд

## Облачные вычисления

Облако представляет собой вид поставки вычислительных сервисов по требованию с оплатой за использованное количество ресурсов. 

К преимуществам можно отнести:
- предоставление сервисов, доступных в разных географических областях
- аутсорсинг размещения серверов в стойках, настройки аппаратного обеспечения и охрана ЦОДов
- высокая пропускная способность
- шифрование хранимых данных
- архитектурная избыточность обеспечивает масштабирование

Закон Мура перестал действовать к концу 2015 года. CPU предназначены для многоцелевого использования, а не для выполнения параллельных заданий, и увеличение числа используемых ядер ничего не дает. Для того, чтобы увеличить производительность, облака используют специфическое аппаратное обеспечение (ASIC) для разных задач. Они предлагают использовать возможности конкурентности платформы (бессерверную обработку данных, пакетную обработку и спотовые инстансы), а не конкурентную обработку (самостоятельную оптимизацию на конкретном ЯП), то есть предлагают стоять на плечах гигантов.

[Гайды AWS](https://aws.amazon.com/whitepapers/?whitepapers-main.sort-by=item.additionalFields.sortDate&whitepapers-main.sort-order=desc&awsf.whitepapers-content-type=*all&awsf.whitepapers-tech-category=*all&awsf.whitepapers-industries=*all&awsf.whitepapers-business-category=*all&awsf.whitepapers-global-methodology=*all)

### Типы сервисов

Частные облака реулизуются в OpenStack. Гибридные облака реализуются для аренды специфического оборудования (FPGA,TPU). Мультиоблака подразумевают использование нескольких поставщиков в целях получения наибольшей выгоды из рынка и возможны при помощи конфигурации Terraform и переносимости контейнеров.

- IaaS: виртуальные машины, программно определяемые сети и хранилища (SDN и SDS). AWS сервисы: S3, EC2, SQS, EFS
- MaaS: аутсорсинг поддержки специфического **аппаратного обеспечения**, например, базы данных на GPU
- PaaS: отличается от IaaS наличием **среды разработки**, интегрируемыми сервисами (аутентификацией, БД). Сервисы: Heroku, Google App Engine
- FaaS (бессерверная обработка)

Аппаратная виртуализация бывает двух типов: паравиртуализация и HVM. Отличие в том, что HVM может применять аппаратные расширения. Помимо запуска нескольких ОС на одном хосте это позволяет распределять между ними ресурсы CPU, ввода-вывода и ОЗУ. Это позволяет гибко и экономно перераспределять их в зависимости от потребностей клиентов (так SDS наращивают объемы ввода-вывода).

### Контейнеры

Линтер для Dockerfile - `hadolint`.

Контейнеры представляют собой **виртуализацию уровня ОС**. 
- У всех поставщиков облачных сервисов есть Docker-registry, где хранятся пользовательские контейнеры и Kubernetes как опция
- Большинство сервисов сборки имеет тесную интеграцию с Docker API

## Python

`http.server` можно использовать только для тестирования, поскольку он не умеет обрабатывать сразу несколько запросов.

### Реактивные библиотеки CLI
Ускорить написание консольных приложений позволяет переход с `argparse` на `fire` или `click`. Первый реализован благодаря интроспекции кода, второй посредством декораторов. `fire` требует от проекта ООП и не позволяет вручную править справку по командам.
### Обход JIT
Для решения проблем с быстродействием используется динамический компилятор `Numba`, позвляющий обойти JIT и использовать многопоточность:
```
@numba.jit(nopython=True) # или parallel=True
def factorial(x, n):
    if n:
        return factorial(x, n - 1) * x
    return 1
```
### Использование Python вместе с Bash

Python из Bash можно запускать при помощи флага `-c` и функции `exec()`, аргументы которой можно предварительно закодировать в base64.
```
try() {
  python -c "
exec('''
try: 
    import ${1} as _
    print(_.__file__)
except:
    print('Module not found')
''')"
}
```
### Таймаут ожидания дочернего процесса
```
subprocess.run(["sleep", "3"], timeout=4)
```
### Создание пакетов

#### PyPi

Для создания пакета используется `setuptools`, для загрузки на PyPi - `twine`.
В файле `setup.py` импортируются функции `setup`, инициализирующая описание пакета и `find_packages`, автоматически находящую файлы Python. В `setup` можно указать **trove classifiers**, содержащие ЯП, лицензию, целевую ОС и др.

Для реализации локального репозитория рекомендуется использовать `devpi`.

#### Debian
Использовать `dch` из `devscripts` для создания changelog пакета `.deb`. Для генерации двоичного файла использовать `debuild` со встроенным линетром `lintian`. Локальный репозиторий можно создать при помощи `reprepro`.

#### RPM
Требует только файла `spec` и утилиту `rpmbuild`.





