## Docker

**Контейнеризация** — метод виртуализации в UNIX, при котором ядро ОС поддерживает несколько изолированных пространств пользователя **без резервирования ресурсов**.

Любой контейнер можно остановить, перезапустить или уничтожить, если это необходимо. Данные, которые содержатся в контейнере, при этом тоже пропадут. Так выработалось правило проектирования приложений: не хранить важные данные в контейнере. Такой подход называют stateless.

**Контейнеризация** — метод виртуализации в UNIX, при котором ядро ОС поддерживает несколько изолированных пространств пользователя без резервирования ресурсов. Виртуальные машины недоутилизируют ресурсы сервера: процессор, память, диски выделяются на каждую ОС.

Пространства имен, поддерживаемые ядром:
- user namespace - реализует разграничение доступа по uid и guid между процессами
- PID namespace - позволяет реализовать дополнительный уровень изоляции внутри одного дерева процессов, не позволяя им видеть процессы из других деревьев
- network namespace - собственная приватная таблица маршрутизации, наборы IP-адресов, сокеты, fw
- mount namespace - позволяет монтировать и размонтировать устройства в одном неймспейсе
- IPC namespace - не позволяет отправлять сигналы в другие неймспейсы 

Механизм контрольных групп cgroups состоит из двух частей: основы (ядра) и контроллеров. Основа организует иерархию процессов, контроллеры управляют ресурсами системы. Главные контроллеры CPU и memory.

Таким образом, разделение памяти и ЦПУ между контейнерами осуществляется при помощи cgroups, а между другими ресурсами - при помощи namespaces.

Помимо них, Docker использует компоненты Union File System (ФС со слоями), seccomp (ограничивает системные вызовы хоста) и capabilities (выдает права на хосте) 

ENTRYPOINT отличается от CMD тем, что при использовании только CMD входной точкой является /bin/sh -c, и его можно переопределить флагом --command. Для переопределения ENTRYPOINT придется пересобирать контейнер.

Для передачи временных файлов внутрь контейнера, например, `requirements.txt`, лучше использовать bind-mounts:
```
RUN --mount=type=bind,source=requirements.txt,target=/tmp/requirements.txt \
    pip install --requirement /tmp/requirements.txt
```


#### Multi-stage builds

Использует несколько инструкций FROM для создания контейнера-сборщика и финального контейнера. Полезно в случаях, когда собирается исполняемый файл, который затем используется внутри sketch-контейнера.